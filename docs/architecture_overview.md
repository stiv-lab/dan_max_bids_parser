# **Architecture Overview (High-Level Design)**

**Система: Универсальный ETL-парсер заявок (Дан-Макс)**
**Версия документа:** 1.0
**Назначение:** формализовать архитектурные принципы, слои, ответственность модулей и перечень сущностей, которые можно менять без деплоя.

---

# 1. Архитектурные принципы

## 1.1. Clean Architecture / Ports & Adapters

Система строго разделена на слои:

1. **Domain**
   Модели, бизнес-правила, доменные сервисы.
   Не знает о БД, HTTP, Telegram, API конкретных площадок.

2. **Application (Use Cases)**
   Координация выполнения сценариев:

   * запуск парсинга источников,
   * обработка сырых данных,
   * нормализация, фильтрация, дедупликация,
   * экспорт результатов,
   * сбор и публикация отчётов.

3. **Interfaces**
   CLI, REST API, Web UI (на следующих этапах).
   Только принимают запросы, отдают ответы и вызывают use-cases.

4. **Infrastructure**
   Внешние реализации:

   * PostgreSQL (Storage),
   * HTML/API/Telegram/WhatsApp adapters,
   * Anti-bot & Proxy,
   * Export adapters (Excel/Google Sheets),
   * Scheduler.

Логика домена никогда не импортирует инфраструктуру.

## 1.2. ETL-ядро как фундамент

Вся система представляет собой универсальный ETL-пайплайн:

**Extract → Parse → Normalize → Classify → Filter → Deduplicate → Store → Export → Notify**

Каждый шаг должен быть:

* идемпотентным,
* настраиваемым,
* легко заменяемым через интерфейсы,
* независимым от конкретной площадки.

## 1.3. Конфигурация важнее кода

Ряд сущностей должен изменяться **без деплоя обновлённого кода**, и находиться как в тесте, так и в проде, не затрагиваясь автоматическими миграциями при обновлениях.

## 1.4. Масштабируемость

Система должна поддерживать:

* рост числа источников,
* параллельную обработку,
* вынесение задач в очереди (в дальнейшем),
* разбиение источников по воркерам.

Основная единица масштабирования — **задача парсинга источника/страницы/сообщения**.

---

# 2. Доменная модель (Domain Layer)

## 2.1. Сущности

* `Source` — источник данных (HTML/API/Telegram/WhatsApp).

* `RawItem` — сырой объект: HTML, JSON, сообщение.

* `Bid` — нормализованная заявка:

  * external_id,
  * title, description,
  * cargo_type, transport_type,
  * route (load/unload),
  * weight, price, currency,
  * contact, url,
  * published_at, received_at.

* `FilterRule` — правила включения/исключения.

* `DeduplicationKey` — стратегия выявления дублей.

* `ParsingJob` / `HarvestingJob` — задание ETL.

## 2.2. Доменные сервисы

* `BidClassifier` — определение типа груза по словам/моделям.
* `Normalizer` — нормализация дат, городов, телефонов.
* `BidFilter` — применение фильтрации.
* `BidDeduplicator` — поиск дублей.
* `SourceSchedulePolicy` — правила расписания.

---

# 3. Уровень приложений (Application / Use Cases)

Основные use-cases:

1. `RunSourceHarvesting(source_id)`
2. `ReprocessRawItems()`
3. `ExportBidsToXlsx / ExportBidsToGoogleSheets`
4. `GenerateDailyHealthReport`
5. `ManageSourceSchedule`

Use-cases обращаются только к абстрактным портам:

* `RawItemProvider`,
* `ParserPort`,
* `ConfigService`,
* `BidRepository`,
* `ExportPort`,
* `AlertingPort`.

---

# 4. Интерфейсы (Interfaces)

* **CLI** для ручного запуска и отладки.
* **REST API** (на следующих этапах): получение/поиск заявок.
* **Web UI** (этап 2): управление источниками, расписаниями, фильтрами, просмотр лога и статистики.

Интерфейсы не содержат бизнес-логики.

---

# 5. Инфраструктура (Infrastructure)

## 5.1. Источники (Adapters)

* HTML/Web API Providers (httpx/requests).
* JS-driven sites (Playwright при необходимости).
* Telegram Adapter (aiogram/Telethon).
* WhatsApp Adapter (по технической возможности).

Все работают поверх единых интерфейсов `RawItemProvider`.

## 5.2. Anti-bot / Proxy Layer

Универсальный модуль:

* `ProxyManager`
* `UserAgentProvider`
* `RequestThrottler`
* `CaptchaSolverPort`

Используется всеми web-адаптерами.

## 5.3. Storage Layer

База данных — PostgreSQL.
Используем:

* SQLAlchemy ORM,
* Alembic для схемы,
* Таблицы: `sources`, `raw_items`, `bids`, `config_*`, `jobs`, `errors`.

## 5.4. Export Layer

Универсальные адаптеры:

* Excel (XLSX),
* CSV,
* Google Sheets.

## 5.5. Scheduler

* На MVP: cron или APScheduler.
* В перспективе: отдельные воркеры и очередь задач.

## 5.6. Monitoring & Alerts

* Логи в JSON.
* Модуль `AlertingPort`: Telegram/SMS/e-mail.
* Позже — Prometheus/Grafana.

---

# 6. **Сущности, изменяемые без деплоя**

(ключевой раздел)

Все настройки, которые можно менять без обновления кода, хранятся **в БД** в таблицах `config_*` или в схеме `config`.

## 6.1. Перечень конфигурационных сущностей

1. **SourceConfig**

   * включён/выключен,
   * ссылки/endpoint’ы,
   * параметры авторизации (типы, но не секреты),
   * лимиты запросов и задержек,
   * приоритет.

2. **FilterRuleConfig**

   * по грузу, маршруту, цене, региону, транспортному средству, ключевым словам.
   * включение/отключение отдельных правил.

3. **ClassifierConfig**

   * словари ключевых слов, регулярки, правила определения типов.

4. **DeduplicationConfig**

   * ключи дублей: external_id, текстовые поля, комбинации данных.

5. **ScheduleConfig**

   * расписания (cron/interval),
   * политики повторов и backoff.

6. **AntiBotProfiles**

   * связка “источник → прокси/UA/лимиты”.

7. **ExportConfig**

   * пути, параметры листов Google Sheets,
   * стратегии отбора выгружаемых заявок.

8. **NotificationTemplates**

   * тексты оповещений для Telegram.

## 6.2. Принцип независимости от деплоя

### 1. **Alembic не трогает данные `config_*`**

Только изменяет схему.

### 2. Боевые значения управляются вручную/UI

Не изменяются программно при релизах.

### 3. Тест и Прод используют разные БД / схемы

* Схема одинакова (миграции),
* Данные в `config_*` разные и независимы.

### 4. Начальные конфиги (seed)

Могут быть в виде YAML/JSON в репозитории.
Prod применяется вручную после ревью, не автоматически.

---

# 7. Универсальные переиспользуемые модули

1. **`stiv_scraper_core`** — HTTP/parsing/anti-bot engine.
2. **`stiv_etl_core`** — конвейеры Extract/Transform/Load.
3. **`stiv_anti_bot`** — Proxy, Captcha, throttle.
4. **`stiv_monitoring`** — логирование, алерты.
5. **`stiv_export`** — Excel/CSV/Sheets.

Система Дан-Макс — частный случай, использующий эти модули.

---

# 8. Масштабирование

## Этап 1 (MVP)

* Один сервис, несколько потоков, cron.
* Основной упор на корректность парсинга и универсальность архитектуры.

## Этап 2

* Воркеры по источникам.
* Очередь задач (Redis/RabbitMQ).
* Независимое масштабирование по нагрузке.

## Этап 3

* Полный отказоустойчивый пайплайн с горизонтальным расширением.
* Managed PostgreSQL, Prometheus/Grafana.

---

# 9. Правила расширения системы

1. Добавление нового источника — в идеале только новый адаптер + конфиг.
2. Расширение классификаторов и фильтров — меняется в `config_*`, без деплоя.
3. Изменение пайплайна — через код/деплой.
4. Добавление нового канала экспорта — код/деплой.
5. Изменение параметров антибот-профилей — без деплоя.

---

# 10. Политика Git и CI/CD (общее)

* Все изменения кода — через Pull Request.
* Миграции — только для схемы, не для данных конфигурации.
* Прод конфигурация — хранится только в БД, не в коде.

---

# 11. Итог

В документе зафиксированы:

* архитектурные принципы,
* слои и ответственность модулей,
* правила расширения,
* каталог универсальных сущностей,
* перечень конфигурационных объектов, которые изменяются **без деплоя**,
* строгая политика разделения схемы и конфигурационных данных,
* требования к тест/прод развёртыванию.

---
